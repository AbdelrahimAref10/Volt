//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.3.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class AdminClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    login(command: AdminLoginCommand): Observable<AdminLoginResponse> {
        let url_ = this.baseUrl + "/api/Admin/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminLoginResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminLoginResponse>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<AdminLoginResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminLoginResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class AdminCustomerClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(pageNumber?: number | undefined, pageSize?: number | undefined, searchTerm?: string | null | undefined, state?: CustomerState | null | undefined, cityId?: number | null | undefined, registerAs?: number | null | undefined): Observable<PagedResultOfCustomerDto> {
        let url_ = this.baseUrl + "/api/AdminCustomer?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (state !== undefined && state !== null)
            url_ += "State=" + encodeURIComponent("" + state) + "&";
        if (cityId !== undefined && cityId !== null)
            url_ += "CityId=" + encodeURIComponent("" + cityId) + "&";
        if (registerAs !== undefined && registerAs !== null)
            url_ += "RegisterAs=" + encodeURIComponent("" + registerAs) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultOfCustomerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultOfCustomerDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultOfCustomerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfCustomerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: AdminCreateCustomerCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/AdminCustomer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(id: number): Observable<CustomerDto> {
        let url_ = this.baseUrl + "/api/AdminCustomer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<CustomerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    block(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/AdminCustomer/{id}/block";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBlock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBlock(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processBlock(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    unblock(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/AdminCustomer/{id}/unblock";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnblock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnblock(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUnblock(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    activate(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/AdminCustomer/{id}/activate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deactivate(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/AdminCustomer/{id}/deactivate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeactivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeactivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeactivate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    blockCash(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/AdminCustomer/{id}/block-cash";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBlockCash(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBlockCash(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processBlockCash(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    unblockCash(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/AdminCustomer/{id}/unblock-cash";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnblockCash(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnblockCash(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUnblockCash(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class AdminDashboardClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getDashboardAnalytics(recentOrdersCount?: number | undefined, topCategoriesCount?: number | undefined, revenuePeriodsCount?: number | undefined): Observable<AdminDashboardAnalyticsDto> {
        let url_ = this.baseUrl + "/api/AdminDashboard/Analytics?";
        if (recentOrdersCount === null)
            throw new Error("The parameter 'recentOrdersCount' cannot be null.");
        else if (recentOrdersCount !== undefined)
            url_ += "recentOrdersCount=" + encodeURIComponent("" + recentOrdersCount) + "&";
        if (topCategoriesCount === null)
            throw new Error("The parameter 'topCategoriesCount' cannot be null.");
        else if (topCategoriesCount !== undefined)
            url_ += "topCategoriesCount=" + encodeURIComponent("" + topCategoriesCount) + "&";
        if (revenuePeriodsCount === null)
            throw new Error("The parameter 'revenuePeriodsCount' cannot be null.");
        else if (revenuePeriodsCount !== undefined)
            url_ += "revenuePeriodsCount=" + encodeURIComponent("" + revenuePeriodsCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardAnalytics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardAnalytics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdminDashboardAnalyticsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdminDashboardAnalyticsDto>;
        }));
    }

    protected processGetDashboardAnalytics(response: HttpResponseBase): Observable<AdminDashboardAnalyticsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminDashboardAnalyticsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class AdminOrderClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllOrders(pageNumber?: number | undefined, pageSize?: number | undefined, state?: OrderState | null | undefined, orderCode?: string | null | undefined): Observable<PagedResultOfOrderDto> {
        let url_ = this.baseUrl + "/api/AdminOrder?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (state !== undefined && state !== null)
            url_ += "State=" + encodeURIComponent("" + state) + "&";
        if (orderCode !== undefined && orderCode !== null)
            url_ += "OrderCode=" + encodeURIComponent("" + orderCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultOfOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultOfOrderDto>;
        }));
    }

    protected processGetAllOrders(response: HttpResponseBase): Observable<PagedResultOfOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOrderById(id: number): Observable<OrderDetailDto> {
        let url_ = this.baseUrl + "/api/AdminOrder/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDetailDto>;
        }));
    }

    protected processGetOrderById(response: HttpResponseBase): Observable<OrderDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateOrderState(orderId: number, command: UpdateOrderStateCommand): Observable<OrderDto> {
        let url_ = this.baseUrl + "/api/AdminOrder/{orderId}/UpdateState";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrderState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrderState(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDto>;
        }));
    }

    protected processUpdateOrderState(response: HttpResponseBase): Observable<OrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    cancelOrder(orderId: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/AdminOrder/{orderId}/Cancel";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCancelOrder(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOrdersByStateReport(): Observable<OrdersByStateReportDto[]> {
        let url_ = this.baseUrl + "/api/AdminOrder/Reports/OrdersByState";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrdersByStateReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrdersByStateReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrdersByStateReportDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrdersByStateReportDto[]>;
        }));
    }

    protected processGetOrdersByStateReport(response: HttpResponseBase): Observable<OrdersByStateReportDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrdersByStateReportDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOrdersByDateRangeReport(fromDate?: Date | undefined, toDate?: Date | undefined): Observable<OrderDto[]> {
        let url_ = this.baseUrl + "/api/AdminOrder/Reports/OrdersByDateRange?";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrdersByDateRangeReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrdersByDateRangeReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDto[]>;
        }));
    }

    protected processGetOrdersByDateRangeReport(response: HttpResponseBase): Observable<OrderDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRevenueReport(period?: string | undefined): Observable<RevenueReportDto> {
        let url_ = this.baseUrl + "/api/AdminOrder/Reports/Revenue?";
        if (period === null)
            throw new Error("The parameter 'period' cannot be null.");
        else if (period !== undefined)
            url_ += "Period=" + encodeURIComponent("" + period) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRevenueReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRevenueReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RevenueReportDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RevenueReportDto>;
        }));
    }

    protected processGetRevenueReport(response: HttpResponseBase): Observable<RevenueReportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RevenueReportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCancellationReport(): Observable<CancellationReportDto> {
        let url_ = this.baseUrl + "/api/AdminOrder/Reports/Cancellations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCancellationReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCancellationReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CancellationReportDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CancellationReportDto>;
        }));
    }

    protected processGetCancellationReport(response: HttpResponseBase): Observable<CancellationReportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CancellationReportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getVehicleUtilizationReport(): Observable<VehicleUtilizationReportDto[]> {
        let url_ = this.baseUrl + "/api/AdminOrder/Reports/VehicleUtilization";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVehicleUtilizationReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVehicleUtilizationReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VehicleUtilizationReportDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VehicleUtilizationReportDto[]>;
        }));
    }

    protected processGetVehicleUtilizationReport(response: HttpResponseBase): Observable<VehicleUtilizationReportDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VehicleUtilizationReportDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCustomerOrderHistoryReport(customerId?: number | undefined): Observable<OrderDto[]> {
        let url_ = this.baseUrl + "/api/AdminOrder/Reports/CustomerOrderHistory?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerOrderHistoryReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerOrderHistoryReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDto[]>;
        }));
    }

    protected processGetCustomerOrderHistoryReport(response: HttpResponseBase): Observable<OrderDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTreasuryBalanceReport(): Observable<TreasuryReportDto> {
        let url_ = this.baseUrl + "/api/AdminOrder/Reports/TreasuryBalance";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTreasuryBalanceReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTreasuryBalanceReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TreasuryReportDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TreasuryReportDto>;
        }));
    }

    protected processGetTreasuryBalanceReport(response: HttpResponseBase): Observable<TreasuryReportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TreasuryReportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRevenueByPeriodReport(period?: string | undefined, numberOfPeriods?: number | undefined): Observable<RevenueReportDto[]> {
        let url_ = this.baseUrl + "/api/AdminOrder/Reports/RevenueByPeriod?";
        if (period === null)
            throw new Error("The parameter 'period' cannot be null.");
        else if (period !== undefined)
            url_ += "Period=" + encodeURIComponent("" + period) + "&";
        if (numberOfPeriods === null)
            throw new Error("The parameter 'numberOfPeriods' cannot be null.");
        else if (numberOfPeriods !== undefined)
            url_ += "NumberOfPeriods=" + encodeURIComponent("" + numberOfPeriods) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRevenueByPeriodReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRevenueByPeriodReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RevenueReportDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RevenueReportDto[]>;
        }));
    }

    protected processGetRevenueByPeriodReport(response: HttpResponseBase): Observable<RevenueReportDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RevenueReportDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCancellationFeesReport(): Observable<OrderCancellationFeeDto[]> {
        let url_ = this.baseUrl + "/api/AdminOrder/Reports/CancellationFees";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCancellationFeesReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCancellationFeesReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderCancellationFeeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderCancellationFeeDto[]>;
        }));
    }

    protected processGetCancellationFeesReport(response: HttpResponseBase): Observable<OrderCancellationFeeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderCancellationFeeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class AdminUserClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(pageNumber?: number | undefined, pageSize?: number | undefined, searchTerm?: string | null | undefined, role?: string | null | undefined, active?: boolean | null | undefined): Observable<PagedResultOfUserDto> {
        let url_ = this.baseUrl + "/api/AdminUser?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (role !== undefined && role !== null)
            url_ += "Role=" + encodeURIComponent("" + role) + "&";
        if (active !== undefined && active !== null)
            url_ += "Active=" + encodeURIComponent("" + active) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultOfUserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultOfUserDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultOfUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateUserCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/AdminUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(id: number): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/AdminUser/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateUserCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/AdminUser/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/AdminUser/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    activate(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/AdminUser/{id}/activate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deactivate(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/AdminUser/{id}/deactivate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeactivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeactivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeactivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CategoryClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(pageNumber?: number | undefined, pageSize?: number | undefined): Observable<PagedResultOfCategoryDto> {
        let url_ = this.baseUrl + "/api/Category?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultOfCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultOfCategoryDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultOfCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateCategoryCommand): Observable<CategoryDto> {
        let url_ = this.baseUrl + "/api/Category";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateCategoryCommand): Observable<CategoryDto> {
        let url_ = this.baseUrl + "/api/Category";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getLookup(): Observable<CategoryLookupDto[]> {
        let url_ = this.baseUrl + "/api/Category/lookup";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLookup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLookup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryLookupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryLookupDto[]>;
        }));
    }

    protected processGetLookup(response: HttpResponseBase): Observable<CategoryLookupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategoryLookupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CityClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(pageNumber?: number | undefined, pageSize?: number | undefined, searchTerm?: string | null | undefined, isActive?: boolean | null | undefined): Observable<PagedResultOfCityDto> {
        let url_ = this.baseUrl + "/api/City?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultOfCityDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultOfCityDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultOfCityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfCityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    add(command: AddCityCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/City";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateCityCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/City";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(id: number): Observable<CityDto> {
        let url_ = this.baseUrl + "/api/City/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<CityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deactivate(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/City/{id}/deactivate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeactivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeactivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeactivate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    activate(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/City/{id}/activate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    permanentlyDelete(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/City/{id}/permanent";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPermanentlyDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPermanentlyDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processPermanentlyDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CustomerCategoriesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllActiveCategories(): Observable<CategoryDto[]> {
        let url_ = this.baseUrl + "/api/CustomerCategories/GetAllActiveCategories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllActiveCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllActiveCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDto[]>;
        }));
    }

    protected processGetAllActiveCategories(response: HttpResponseBase): Observable<CategoryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CustomerClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    register(command: RegisterCustomerCommand): Observable<RegisterCustomerResponse> {
        let url_ = this.baseUrl + "/api/Customer/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterCustomerResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterCustomerResponse>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterCustomerResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterCustomerResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    activate(command: ActivateCustomerCommand): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Customer/Activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    login(command: CustomerLoginCommand): Observable<LoginResponse> {
        let url_ = this.baseUrl + "/api/Customer/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResponse>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<LoginResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    refreshToken(command: RefreshTokenCommand): Observable<RefreshTokenResponse> {
        let url_ = this.baseUrl + "/api/Customer/RefreshToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RefreshTokenResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RefreshTokenResponse>;
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<RefreshTokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RefreshTokenResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getActiveCities(): Observable<CityLookupDto[]> {
        let url_ = this.baseUrl + "/api/Customer/GetActiveCities";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveCities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveCities(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityLookupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityLookupDto[]>;
        }));
    }

    protected processGetActiveCities(response: HttpResponseBase): Observable<CityLookupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CityLookupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CustomerOrderClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getCityFees(): Observable<CityFeesDto> {
        let url_ = this.baseUrl + "/api/CustomerOrder/CityFees";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCityFees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCityFees(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityFeesDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityFeesDto>;
        }));
    }

    protected processGetCityFees(response: HttpResponseBase): Observable<CityFeesDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CityFeesDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getReservedVehiclePerSubCategory(subCategoryId?: number | undefined): Observable<ReservedDateDto[]> {
        let url_ = this.baseUrl + "/api/CustomerOrder/ReservedVehiclePerSubCategory?";
        if (subCategoryId === null)
            throw new Error("The parameter 'subCategoryId' cannot be null.");
        else if (subCategoryId !== undefined)
            url_ += "subCategoryId=" + encodeURIComponent("" + subCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReservedVehiclePerSubCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReservedVehiclePerSubCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReservedDateDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReservedDateDto[]>;
        }));
    }

    protected processGetReservedVehiclePerSubCategory(response: HttpResponseBase): Observable<ReservedDateDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReservedDateDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createOrder(command: CreateOrderCommand): Observable<OrderDto> {
        let url_ = this.baseUrl + "/api/CustomerOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDto>;
        }));
    }

    protected processCreateOrder(response: HttpResponseBase): Observable<OrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getMyOrders(pageNumber?: number | undefined, pageSize?: number | undefined): Observable<PagedResultOfOrderDto> {
        let url_ = this.baseUrl + "/api/CustomerOrder/MyOrders?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultOfOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultOfOrderDto>;
        }));
    }

    protected processGetMyOrders(response: HttpResponseBase): Observable<PagedResultOfOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    cancelOrder(orderId: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/CustomerOrder/{orderId}/Cancel";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCancelOrder(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    completePayPalPayment(request: CompletePayPalPaymentRequestDto): Observable<CompletePayPalPaymentResponseDto> {
        let url_ = this.baseUrl + "/api/CustomerOrder/CompletePayPalPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompletePayPalPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompletePayPalPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompletePayPalPaymentResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompletePayPalPaymentResponseDto>;
        }));
    }

    protected processCompletePayPalPayment(response: HttpResponseBase): Observable<CompletePayPalPaymentResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompletePayPalPaymentResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CustomerSubCategoryClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllActiveSubcategories(): Observable<SubCategoryDto[]> {
        let url_ = this.baseUrl + "/api/CustomerSubCategory/GetAllActiveSubcategories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllActiveSubcategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllActiveSubcategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubCategoryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubCategoryDto[]>;
        }));
    }

    protected processGetAllActiveSubcategories(response: HttpResponseBase): Observable<SubCategoryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubCategoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllOffers(): Observable<SubCategoryDto[]> {
        let url_ = this.baseUrl + "/api/CustomerSubCategory/GetAllOffers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOffers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOffers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubCategoryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubCategoryDto[]>;
        }));
    }

    protected processGetAllOffers(response: HttpResponseBase): Observable<SubCategoryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubCategoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class RoleClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllRoles(): Observable<RoleDto[]> {
        let url_ = this.baseUrl + "/api/Role/AllRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto[]>;
        }));
    }

    protected processGetAllRoles(response: HttpResponseBase): Observable<RoleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RoleDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRoleById(roleId: number): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/Role/GetRoleById/{roleId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processGetRoleById(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserRoles(userId: number): Observable<RoleDto[]> {
        let url_ = this.baseUrl + "/api/Role/GetUserRoles/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto[]>;
        }));
    }

    protected processGetUserRoles(response: HttpResponseBase): Observable<RoleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RoleDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createRole(command: CreateRoleCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Role/CreateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateRole(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateRole(command: UpdateRoleCommand): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Role/UpdateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdateRole(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRole(roleId: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Role/DeleteRole/{roleId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    assignRoleToUser(command: AssignRoleToUserCommand): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Role/AssignRoleToUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignRoleToUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignRoleToUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAssignRoleToUser(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeRoleFromUser(command: RemoveRoleFromUserCommand): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Role/RemoveRoleFromUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveRoleFromUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveRoleFromUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processRemoveRoleFromUser(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class SubCategoryClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(pageNumber?: number | undefined, pageSize?: number | undefined, categoryId?: number | null | undefined, searchTerm?: string | null | undefined): Observable<PagedResultOfSubCategoryDto> {
        let url_ = this.baseUrl + "/api/SubCategory?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (categoryId !== undefined && categoryId !== null)
            url_ += "CategoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultOfSubCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultOfSubCategoryDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultOfSubCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfSubCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateSubCategoryCommand): Observable<SubCategoryDto> {
        let url_ = this.baseUrl + "/api/SubCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubCategoryDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<SubCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateSubCategoryCommand): Observable<SubCategoryDto> {
        let url_ = this.baseUrl + "/api/SubCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubCategoryDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SubCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(id: number): Observable<SubCategoryDto> {
        let url_ = this.baseUrl + "/api/SubCategory/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubCategoryDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<SubCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/SubCategory/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByCategory(categoryId: number): Observable<SubCategoryDto[]> {
        let url_ = this.baseUrl + "/api/SubCategory/by-category/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubCategoryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubCategoryDto[]>;
        }));
    }

    protected processGetByCategory(response: HttpResponseBase): Observable<SubCategoryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubCategoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getLookup(categoryId?: number | null | undefined): Observable<SubCategoryLookupDto[]> {
        let url_ = this.baseUrl + "/api/SubCategory/lookup?";
        if (categoryId !== undefined && categoryId !== null)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLookup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLookup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubCategoryLookupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubCategoryLookupDto[]>;
        }));
    }

    protected processGetLookup(response: HttpResponseBase): Observable<SubCategoryLookupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubCategoryLookupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class VehicleClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(pageNumber?: number | undefined, pageSize?: number | undefined, searchTerm?: string | null | undefined, categoryId?: number | null | undefined, subCategoryId?: number | null | undefined, status?: string | null | undefined): Observable<PagedResultOfVehicleDto> {
        let url_ = this.baseUrl + "/api/Vehicle?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (categoryId !== undefined && categoryId !== null)
            url_ += "CategoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (subCategoryId !== undefined && subCategoryId !== null)
            url_ += "SubCategoryId=" + encodeURIComponent("" + subCategoryId) + "&";
        if (status !== undefined && status !== null)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultOfVehicleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultOfVehicleDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultOfVehicleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfVehicleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateVehicleCommand): Observable<VehicleDto> {
        let url_ = this.baseUrl + "/api/Vehicle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VehicleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VehicleDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<VehicleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehicleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateVehicleCommand): Observable<VehicleDto> {
        let url_ = this.baseUrl + "/api/Vehicle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VehicleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VehicleDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<VehicleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehicleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getStatistics(categoryId?: number | null | undefined, subCategoryId?: number | null | undefined): Observable<VehicleStatisticsDto> {
        let url_ = this.baseUrl + "/api/Vehicle/statistics?";
        if (categoryId !== undefined && categoryId !== null)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (subCategoryId !== undefined && subCategoryId !== null)
            url_ += "subCategoryId=" + encodeURIComponent("" + subCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatistics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VehicleStatisticsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VehicleStatisticsDto>;
        }));
    }

    protected processGetStatistics(response: HttpResponseBase): Observable<VehicleStatisticsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehicleStatisticsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByCategory(categoryId: number, pageNumber?: number | undefined, pageSize?: number | undefined): Observable<PagedResultOfVehicleDto> {
        let url_ = this.baseUrl + "/api/Vehicle/by-category/{categoryId}?";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultOfVehicleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultOfVehicleDto>;
        }));
    }

    protected processGetByCategory(response: HttpResponseBase): Observable<PagedResultOfVehicleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfVehicleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getBySubCategory(subCategoryId: number, pageNumber?: number | undefined, pageSize?: number | undefined): Observable<PagedResultOfVehicleDto> {
        let url_ = this.baseUrl + "/api/Vehicle/by-subcategory/{subCategoryId}?";
        if (subCategoryId === undefined || subCategoryId === null)
            throw new Error("The parameter 'subCategoryId' must be defined.");
        url_ = url_.replace("{subCategoryId}", encodeURIComponent("" + subCategoryId));
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBySubCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBySubCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultOfVehicleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultOfVehicleDto>;
        }));
    }

    protected processGetBySubCategory(response: HttpResponseBase): Observable<PagedResultOfVehicleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfVehicleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(id: number): Observable<VehicleDto> {
        let url_ = this.baseUrl + "/api/Vehicle/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VehicleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VehicleDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<VehicleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehicleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Vehicle/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class AdminLoginResponse {
    token!: string;
    refreshToken!: string;
    userId!: number;
    userName!: string;
    roles!: string[];

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"] !== undefined ? _data["token"] : <any>null;
            this.refreshToken = _data["refreshToken"] !== undefined ? _data["refreshToken"] : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            else {
                this.roles = <any>null;
            }
        }
    }

    static fromJS(data: any): AdminLoginResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AdminLoginResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token !== undefined ? this.token : <any>null;
        data["refreshToken"] = this.refreshToken !== undefined ? this.refreshToken : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export class ProblemDetail {
    statusCode!: number;
    errorMessage!: string;
    additioanlData!: any;

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"] !== undefined ? _data["statusCode"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
            this.additioanlData = _data["additioanlData"] !== undefined ? _data["additioanlData"] : <any>null;
        }
    }

    static fromJS(data: any): ProblemDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode !== undefined ? this.statusCode : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        data["additioanlData"] = this.additioanlData !== undefined ? this.additioanlData : <any>null;
        return data;
    }
}

export class AdminLoginCommand {
    userName!: string;
    password!: string;

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): AdminLoginCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AdminLoginCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export class PagedResultOfCustomerDto {
    items!: CustomerDto[];
    totalCount!: number;
    pageNumber!: number;
    pageSize!: number;
    totalPages!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CustomerDto.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
            this.hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            this.hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): PagedResultOfCustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfCustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export class CustomerDto {
    customerId!: number;
    mobileNumber!: string;
    fullName!: string;
    gender!: string;
    personalImage!: string | null;
    fullAddress!: string | null;
    registerAs!: number;
    verificationBy!: number;
    cityId!: number;
    cityName!: string;
    state!: CustomerState;
    cashBlock!: boolean;
    email!: string | null;
    createdDate!: Date;

    init(_data?: any) {
        if (_data) {
            this.customerId = _data["customerId"] !== undefined ? _data["customerId"] : <any>null;
            this.mobileNumber = _data["mobileNumber"] !== undefined ? _data["mobileNumber"] : <any>null;
            this.fullName = _data["fullName"] !== undefined ? _data["fullName"] : <any>null;
            this.gender = _data["gender"] !== undefined ? _data["gender"] : <any>null;
            this.personalImage = _data["personalImage"] !== undefined ? _data["personalImage"] : <any>null;
            this.fullAddress = _data["fullAddress"] !== undefined ? _data["fullAddress"] : <any>null;
            this.registerAs = _data["registerAs"] !== undefined ? _data["registerAs"] : <any>null;
            this.verificationBy = _data["verificationBy"] !== undefined ? _data["verificationBy"] : <any>null;
            this.cityId = _data["cityId"] !== undefined ? _data["cityId"] : <any>null;
            this.cityName = _data["cityName"] !== undefined ? _data["cityName"] : <any>null;
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
            this.cashBlock = _data["cashBlock"] !== undefined ? _data["cashBlock"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): CustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId !== undefined ? this.customerId : <any>null;
        data["mobileNumber"] = this.mobileNumber !== undefined ? this.mobileNumber : <any>null;
        data["fullName"] = this.fullName !== undefined ? this.fullName : <any>null;
        data["gender"] = this.gender !== undefined ? this.gender : <any>null;
        data["personalImage"] = this.personalImage !== undefined ? this.personalImage : <any>null;
        data["fullAddress"] = this.fullAddress !== undefined ? this.fullAddress : <any>null;
        data["registerAs"] = this.registerAs !== undefined ? this.registerAs : <any>null;
        data["verificationBy"] = this.verificationBy !== undefined ? this.verificationBy : <any>null;
        data["cityId"] = this.cityId !== undefined ? this.cityId : <any>null;
        data["cityName"] = this.cityName !== undefined ? this.cityName : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["cashBlock"] = this.cashBlock !== undefined ? this.cashBlock : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>null;
        return data;
    }
}

export enum CustomerState {
    InActive = 0,
    Active = 1,
    Blocked = 2,
}

export class ProblemDetails {
    type!: string | null;
    title!: string | null;
    status!: number | null;
    detail!: string | null;
    instance!: string | null;

    [key: string]: any;

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.detail = _data["detail"] !== undefined ? _data["detail"] : <any>null;
            this.instance = _data["instance"] !== undefined ? _data["instance"] : <any>null;
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["detail"] = this.detail !== undefined ? this.detail : <any>null;
        data["instance"] = this.instance !== undefined ? this.instance : <any>null;
        return data;
    }
}

export class AdminCreateCustomerCommand {
    mobileNumber!: string;
    fullName!: string;
    gender!: string;
    cityId!: number;
    fullAddress!: string | null;
    personalImage!: string | null;
    registerAs!: number;
    verificationBy!: number;
    password!: string;

    init(_data?: any) {
        if (_data) {
            this.mobileNumber = _data["mobileNumber"] !== undefined ? _data["mobileNumber"] : <any>null;
            this.fullName = _data["fullName"] !== undefined ? _data["fullName"] : <any>null;
            this.gender = _data["gender"] !== undefined ? _data["gender"] : <any>null;
            this.cityId = _data["cityId"] !== undefined ? _data["cityId"] : <any>null;
            this.fullAddress = _data["fullAddress"] !== undefined ? _data["fullAddress"] : <any>null;
            this.personalImage = _data["personalImage"] !== undefined ? _data["personalImage"] : <any>null;
            this.registerAs = _data["registerAs"] !== undefined ? _data["registerAs"] : <any>null;
            this.verificationBy = _data["verificationBy"] !== undefined ? _data["verificationBy"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): AdminCreateCustomerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AdminCreateCustomerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mobileNumber"] = this.mobileNumber !== undefined ? this.mobileNumber : <any>null;
        data["fullName"] = this.fullName !== undefined ? this.fullName : <any>null;
        data["gender"] = this.gender !== undefined ? this.gender : <any>null;
        data["cityId"] = this.cityId !== undefined ? this.cityId : <any>null;
        data["fullAddress"] = this.fullAddress !== undefined ? this.fullAddress : <any>null;
        data["personalImage"] = this.personalImage !== undefined ? this.personalImage : <any>null;
        data["registerAs"] = this.registerAs !== undefined ? this.registerAs : <any>null;
        data["verificationBy"] = this.verificationBy !== undefined ? this.verificationBy : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export class AdminDashboardAnalyticsDto {
    overallStatistics!: OverallStatisticsDto;
    orderStatistics!: OrderStatisticsDto;
    revenueAnalytics!: RevenueAnalyticsDto;
    vehicleStatistics!: VehicleStatisticsDto;
    customerStatistics!: CustomerStatisticsDto;
    treasuryBalance!: TreasuryReportDto;
    cancellationStatistics!: CancellationReportDto;
    paymentMethodBreakdown!: PaymentMethodBreakdownDto[];
    topCategories!: TopCategoryDto[];
    recentOrders!: RecentOrderDto[];
    ordersByState!: OrdersByStateReportDto[];

    init(_data?: any) {
        if (_data) {
            this.overallStatistics = _data["overallStatistics"] ? OverallStatisticsDto.fromJS(_data["overallStatistics"]) : <any>null;
            this.orderStatistics = _data["orderStatistics"] ? OrderStatisticsDto.fromJS(_data["orderStatistics"]) : <any>null;
            this.revenueAnalytics = _data["revenueAnalytics"] ? RevenueAnalyticsDto.fromJS(_data["revenueAnalytics"]) : <any>null;
            this.vehicleStatistics = _data["vehicleStatistics"] ? VehicleStatisticsDto.fromJS(_data["vehicleStatistics"]) : <any>null;
            this.customerStatistics = _data["customerStatistics"] ? CustomerStatisticsDto.fromJS(_data["customerStatistics"]) : <any>null;
            this.treasuryBalance = _data["treasuryBalance"] ? TreasuryReportDto.fromJS(_data["treasuryBalance"]) : <any>null;
            this.cancellationStatistics = _data["cancellationStatistics"] ? CancellationReportDto.fromJS(_data["cancellationStatistics"]) : <any>null;
            if (Array.isArray(_data["paymentMethodBreakdown"])) {
                this.paymentMethodBreakdown = [] as any;
                for (let item of _data["paymentMethodBreakdown"])
                    this.paymentMethodBreakdown!.push(PaymentMethodBreakdownDto.fromJS(item));
            }
            else {
                this.paymentMethodBreakdown = <any>null;
            }
            if (Array.isArray(_data["topCategories"])) {
                this.topCategories = [] as any;
                for (let item of _data["topCategories"])
                    this.topCategories!.push(TopCategoryDto.fromJS(item));
            }
            else {
                this.topCategories = <any>null;
            }
            if (Array.isArray(_data["recentOrders"])) {
                this.recentOrders = [] as any;
                for (let item of _data["recentOrders"])
                    this.recentOrders!.push(RecentOrderDto.fromJS(item));
            }
            else {
                this.recentOrders = <any>null;
            }
            if (Array.isArray(_data["ordersByState"])) {
                this.ordersByState = [] as any;
                for (let item of _data["ordersByState"])
                    this.ordersByState!.push(OrdersByStateReportDto.fromJS(item));
            }
            else {
                this.ordersByState = <any>null;
            }
        }
    }

    static fromJS(data: any): AdminDashboardAnalyticsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminDashboardAnalyticsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["overallStatistics"] = this.overallStatistics ? this.overallStatistics.toJSON() : <any>null;
        data["orderStatistics"] = this.orderStatistics ? this.orderStatistics.toJSON() : <any>null;
        data["revenueAnalytics"] = this.revenueAnalytics ? this.revenueAnalytics.toJSON() : <any>null;
        data["vehicleStatistics"] = this.vehicleStatistics ? this.vehicleStatistics.toJSON() : <any>null;
        data["customerStatistics"] = this.customerStatistics ? this.customerStatistics.toJSON() : <any>null;
        data["treasuryBalance"] = this.treasuryBalance ? this.treasuryBalance.toJSON() : <any>null;
        data["cancellationStatistics"] = this.cancellationStatistics ? this.cancellationStatistics.toJSON() : <any>null;
        if (Array.isArray(this.paymentMethodBreakdown)) {
            data["paymentMethodBreakdown"] = [];
            for (let item of this.paymentMethodBreakdown)
                data["paymentMethodBreakdown"].push(item.toJSON());
        }
        if (Array.isArray(this.topCategories)) {
            data["topCategories"] = [];
            for (let item of this.topCategories)
                data["topCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.recentOrders)) {
            data["recentOrders"] = [];
            for (let item of this.recentOrders)
                data["recentOrders"].push(item.toJSON());
        }
        if (Array.isArray(this.ordersByState)) {
            data["ordersByState"] = [];
            for (let item of this.ordersByState)
                data["ordersByState"].push(item.toJSON());
        }
        return data;
    }
}

export class OverallStatisticsDto {
    totalOrders!: number;
    totalCustomers!: number;
    totalVehicles!: number;
    totalCategories!: number;
    totalSubCategories!: number;
    totalCities!: number;
    totalRevenue!: number;
    pendingOrders!: number;
    activeCustomers!: number;
    availableVehicles!: number;

    init(_data?: any) {
        if (_data) {
            this.totalOrders = _data["totalOrders"] !== undefined ? _data["totalOrders"] : <any>null;
            this.totalCustomers = _data["totalCustomers"] !== undefined ? _data["totalCustomers"] : <any>null;
            this.totalVehicles = _data["totalVehicles"] !== undefined ? _data["totalVehicles"] : <any>null;
            this.totalCategories = _data["totalCategories"] !== undefined ? _data["totalCategories"] : <any>null;
            this.totalSubCategories = _data["totalSubCategories"] !== undefined ? _data["totalSubCategories"] : <any>null;
            this.totalCities = _data["totalCities"] !== undefined ? _data["totalCities"] : <any>null;
            this.totalRevenue = _data["totalRevenue"] !== undefined ? _data["totalRevenue"] : <any>null;
            this.pendingOrders = _data["pendingOrders"] !== undefined ? _data["pendingOrders"] : <any>null;
            this.activeCustomers = _data["activeCustomers"] !== undefined ? _data["activeCustomers"] : <any>null;
            this.availableVehicles = _data["availableVehicles"] !== undefined ? _data["availableVehicles"] : <any>null;
        }
    }

    static fromJS(data: any): OverallStatisticsDto {
        data = typeof data === 'object' ? data : {};
        let result = new OverallStatisticsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalOrders"] = this.totalOrders !== undefined ? this.totalOrders : <any>null;
        data["totalCustomers"] = this.totalCustomers !== undefined ? this.totalCustomers : <any>null;
        data["totalVehicles"] = this.totalVehicles !== undefined ? this.totalVehicles : <any>null;
        data["totalCategories"] = this.totalCategories !== undefined ? this.totalCategories : <any>null;
        data["totalSubCategories"] = this.totalSubCategories !== undefined ? this.totalSubCategories : <any>null;
        data["totalCities"] = this.totalCities !== undefined ? this.totalCities : <any>null;
        data["totalRevenue"] = this.totalRevenue !== undefined ? this.totalRevenue : <any>null;
        data["pendingOrders"] = this.pendingOrders !== undefined ? this.pendingOrders : <any>null;
        data["activeCustomers"] = this.activeCustomers !== undefined ? this.activeCustomers : <any>null;
        data["availableVehicles"] = this.availableVehicles !== undefined ? this.availableVehicles : <any>null;
        return data;
    }
}

export class OrderStatisticsDto {
    totalOrders!: number;
    pendingOrders!: number;
    confirmedOrders!: number;
    onWayOrders!: number;
    customerReceivedOrders!: number;
    completedOrders!: number;
    cancelledOrders!: number;
    ordersToday!: number;
    ordersThisWeek!: number;
    ordersThisMonth!: number;
    averageOrderValue!: number;

    init(_data?: any) {
        if (_data) {
            this.totalOrders = _data["totalOrders"] !== undefined ? _data["totalOrders"] : <any>null;
            this.pendingOrders = _data["pendingOrders"] !== undefined ? _data["pendingOrders"] : <any>null;
            this.confirmedOrders = _data["confirmedOrders"] !== undefined ? _data["confirmedOrders"] : <any>null;
            this.onWayOrders = _data["onWayOrders"] !== undefined ? _data["onWayOrders"] : <any>null;
            this.customerReceivedOrders = _data["customerReceivedOrders"] !== undefined ? _data["customerReceivedOrders"] : <any>null;
            this.completedOrders = _data["completedOrders"] !== undefined ? _data["completedOrders"] : <any>null;
            this.cancelledOrders = _data["cancelledOrders"] !== undefined ? _data["cancelledOrders"] : <any>null;
            this.ordersToday = _data["ordersToday"] !== undefined ? _data["ordersToday"] : <any>null;
            this.ordersThisWeek = _data["ordersThisWeek"] !== undefined ? _data["ordersThisWeek"] : <any>null;
            this.ordersThisMonth = _data["ordersThisMonth"] !== undefined ? _data["ordersThisMonth"] : <any>null;
            this.averageOrderValue = _data["averageOrderValue"] !== undefined ? _data["averageOrderValue"] : <any>null;
        }
    }

    static fromJS(data: any): OrderStatisticsDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderStatisticsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalOrders"] = this.totalOrders !== undefined ? this.totalOrders : <any>null;
        data["pendingOrders"] = this.pendingOrders !== undefined ? this.pendingOrders : <any>null;
        data["confirmedOrders"] = this.confirmedOrders !== undefined ? this.confirmedOrders : <any>null;
        data["onWayOrders"] = this.onWayOrders !== undefined ? this.onWayOrders : <any>null;
        data["customerReceivedOrders"] = this.customerReceivedOrders !== undefined ? this.customerReceivedOrders : <any>null;
        data["completedOrders"] = this.completedOrders !== undefined ? this.completedOrders : <any>null;
        data["cancelledOrders"] = this.cancelledOrders !== undefined ? this.cancelledOrders : <any>null;
        data["ordersToday"] = this.ordersToday !== undefined ? this.ordersToday : <any>null;
        data["ordersThisWeek"] = this.ordersThisWeek !== undefined ? this.ordersThisWeek : <any>null;
        data["ordersThisMonth"] = this.ordersThisMonth !== undefined ? this.ordersThisMonth : <any>null;
        data["averageOrderValue"] = this.averageOrderValue !== undefined ? this.averageOrderValue : <any>null;
        return data;
    }
}

export class RevenueAnalyticsDto {
    todayRevenue!: number;
    thisWeekRevenue!: number;
    thisMonthRevenue!: number;
    thisQuarterRevenue!: number;
    thisYearRevenue!: number;
    totalRevenue!: number;
    revenueByPeriod!: RevenueReportDto[];

    init(_data?: any) {
        if (_data) {
            this.todayRevenue = _data["todayRevenue"] !== undefined ? _data["todayRevenue"] : <any>null;
            this.thisWeekRevenue = _data["thisWeekRevenue"] !== undefined ? _data["thisWeekRevenue"] : <any>null;
            this.thisMonthRevenue = _data["thisMonthRevenue"] !== undefined ? _data["thisMonthRevenue"] : <any>null;
            this.thisQuarterRevenue = _data["thisQuarterRevenue"] !== undefined ? _data["thisQuarterRevenue"] : <any>null;
            this.thisYearRevenue = _data["thisYearRevenue"] !== undefined ? _data["thisYearRevenue"] : <any>null;
            this.totalRevenue = _data["totalRevenue"] !== undefined ? _data["totalRevenue"] : <any>null;
            if (Array.isArray(_data["revenueByPeriod"])) {
                this.revenueByPeriod = [] as any;
                for (let item of _data["revenueByPeriod"])
                    this.revenueByPeriod!.push(RevenueReportDto.fromJS(item));
            }
            else {
                this.revenueByPeriod = <any>null;
            }
        }
    }

    static fromJS(data: any): RevenueAnalyticsDto {
        data = typeof data === 'object' ? data : {};
        let result = new RevenueAnalyticsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["todayRevenue"] = this.todayRevenue !== undefined ? this.todayRevenue : <any>null;
        data["thisWeekRevenue"] = this.thisWeekRevenue !== undefined ? this.thisWeekRevenue : <any>null;
        data["thisMonthRevenue"] = this.thisMonthRevenue !== undefined ? this.thisMonthRevenue : <any>null;
        data["thisQuarterRevenue"] = this.thisQuarterRevenue !== undefined ? this.thisQuarterRevenue : <any>null;
        data["thisYearRevenue"] = this.thisYearRevenue !== undefined ? this.thisYearRevenue : <any>null;
        data["totalRevenue"] = this.totalRevenue !== undefined ? this.totalRevenue : <any>null;
        if (Array.isArray(this.revenueByPeriod)) {
            data["revenueByPeriod"] = [];
            for (let item of this.revenueByPeriod)
                data["revenueByPeriod"].push(item.toJSON());
        }
        return data;
    }
}

export class RevenueReportDto {
    totalRevenue!: number;
    totalOrders!: number;
    averageOrderValue!: number;
    period!: string;

    init(_data?: any) {
        if (_data) {
            this.totalRevenue = _data["totalRevenue"] !== undefined ? _data["totalRevenue"] : <any>null;
            this.totalOrders = _data["totalOrders"] !== undefined ? _data["totalOrders"] : <any>null;
            this.averageOrderValue = _data["averageOrderValue"] !== undefined ? _data["averageOrderValue"] : <any>null;
            this.period = _data["period"] !== undefined ? _data["period"] : <any>null;
        }
    }

    static fromJS(data: any): RevenueReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new RevenueReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalRevenue"] = this.totalRevenue !== undefined ? this.totalRevenue : <any>null;
        data["totalOrders"] = this.totalOrders !== undefined ? this.totalOrders : <any>null;
        data["averageOrderValue"] = this.averageOrderValue !== undefined ? this.averageOrderValue : <any>null;
        data["period"] = this.period !== undefined ? this.period : <any>null;
        return data;
    }
}

export class VehicleStatisticsDto {
    totalVehicles!: number;
    availableNow!: number;
    underMaintenance!: number;
    newThisMonth!: number;

    init(_data?: any) {
        if (_data) {
            this.totalVehicles = _data["totalVehicles"] !== undefined ? _data["totalVehicles"] : <any>null;
            this.availableNow = _data["availableNow"] !== undefined ? _data["availableNow"] : <any>null;
            this.underMaintenance = _data["underMaintenance"] !== undefined ? _data["underMaintenance"] : <any>null;
            this.newThisMonth = _data["newThisMonth"] !== undefined ? _data["newThisMonth"] : <any>null;
        }
    }

    static fromJS(data: any): VehicleStatisticsDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleStatisticsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalVehicles"] = this.totalVehicles !== undefined ? this.totalVehicles : <any>null;
        data["availableNow"] = this.availableNow !== undefined ? this.availableNow : <any>null;
        data["underMaintenance"] = this.underMaintenance !== undefined ? this.underMaintenance : <any>null;
        data["newThisMonth"] = this.newThisMonth !== undefined ? this.newThisMonth : <any>null;
        return data;
    }
}

export class CustomerStatisticsDto {
    totalCustomers!: number;
    activeCustomers!: number;
    inactiveCustomers!: number;
    blockedCustomers!: number;
    newCustomersToday!: number;
    newCustomersThisWeek!: number;
    newCustomersThisMonth!: number;
    individualCustomers!: number;
    institutionCustomers!: number;

    init(_data?: any) {
        if (_data) {
            this.totalCustomers = _data["totalCustomers"] !== undefined ? _data["totalCustomers"] : <any>null;
            this.activeCustomers = _data["activeCustomers"] !== undefined ? _data["activeCustomers"] : <any>null;
            this.inactiveCustomers = _data["inactiveCustomers"] !== undefined ? _data["inactiveCustomers"] : <any>null;
            this.blockedCustomers = _data["blockedCustomers"] !== undefined ? _data["blockedCustomers"] : <any>null;
            this.newCustomersToday = _data["newCustomersToday"] !== undefined ? _data["newCustomersToday"] : <any>null;
            this.newCustomersThisWeek = _data["newCustomersThisWeek"] !== undefined ? _data["newCustomersThisWeek"] : <any>null;
            this.newCustomersThisMonth = _data["newCustomersThisMonth"] !== undefined ? _data["newCustomersThisMonth"] : <any>null;
            this.individualCustomers = _data["individualCustomers"] !== undefined ? _data["individualCustomers"] : <any>null;
            this.institutionCustomers = _data["institutionCustomers"] !== undefined ? _data["institutionCustomers"] : <any>null;
        }
    }

    static fromJS(data: any): CustomerStatisticsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerStatisticsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCustomers"] = this.totalCustomers !== undefined ? this.totalCustomers : <any>null;
        data["activeCustomers"] = this.activeCustomers !== undefined ? this.activeCustomers : <any>null;
        data["inactiveCustomers"] = this.inactiveCustomers !== undefined ? this.inactiveCustomers : <any>null;
        data["blockedCustomers"] = this.blockedCustomers !== undefined ? this.blockedCustomers : <any>null;
        data["newCustomersToday"] = this.newCustomersToday !== undefined ? this.newCustomersToday : <any>null;
        data["newCustomersThisWeek"] = this.newCustomersThisWeek !== undefined ? this.newCustomersThisWeek : <any>null;
        data["newCustomersThisMonth"] = this.newCustomersThisMonth !== undefined ? this.newCustomersThisMonth : <any>null;
        data["individualCustomers"] = this.individualCustomers !== undefined ? this.individualCustomers : <any>null;
        data["institutionCustomers"] = this.institutionCustomers !== undefined ? this.institutionCustomers : <any>null;
        return data;
    }
}

export class TreasuryReportDto {
    totalDebit!: number;
    totalCredit!: number;
    balance!: number;
    lastUpdated!: Date;

    init(_data?: any) {
        if (_data) {
            this.totalDebit = _data["totalDebit"] !== undefined ? _data["totalDebit"] : <any>null;
            this.totalCredit = _data["totalCredit"] !== undefined ? _data["totalCredit"] : <any>null;
            this.balance = _data["balance"] !== undefined ? _data["balance"] : <any>null;
            this.lastUpdated = _data["lastUpdated"] ? new Date(_data["lastUpdated"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): TreasuryReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new TreasuryReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalDebit"] = this.totalDebit !== undefined ? this.totalDebit : <any>null;
        data["totalCredit"] = this.totalCredit !== undefined ? this.totalCredit : <any>null;
        data["balance"] = this.balance !== undefined ? this.balance : <any>null;
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toISOString() : <any>null;
        return data;
    }
}

export class CancellationReportDto {
    totalCancelledOrders!: number;
    totalCancellationFees!: number;
    paidCancellationFees!: number;
    unpaidCancellationFees!: number;

    init(_data?: any) {
        if (_data) {
            this.totalCancelledOrders = _data["totalCancelledOrders"] !== undefined ? _data["totalCancelledOrders"] : <any>null;
            this.totalCancellationFees = _data["totalCancellationFees"] !== undefined ? _data["totalCancellationFees"] : <any>null;
            this.paidCancellationFees = _data["paidCancellationFees"] !== undefined ? _data["paidCancellationFees"] : <any>null;
            this.unpaidCancellationFees = _data["unpaidCancellationFees"] !== undefined ? _data["unpaidCancellationFees"] : <any>null;
        }
    }

    static fromJS(data: any): CancellationReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new CancellationReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCancelledOrders"] = this.totalCancelledOrders !== undefined ? this.totalCancelledOrders : <any>null;
        data["totalCancellationFees"] = this.totalCancellationFees !== undefined ? this.totalCancellationFees : <any>null;
        data["paidCancellationFees"] = this.paidCancellationFees !== undefined ? this.paidCancellationFees : <any>null;
        data["unpaidCancellationFees"] = this.unpaidCancellationFees !== undefined ? this.unpaidCancellationFees : <any>null;
        return data;
    }
}

export class PaymentMethodBreakdownDto {
    paymentMethod!: string;
    orderCount!: number;
    totalAmount!: number;
    percentage!: number;

    init(_data?: any) {
        if (_data) {
            this.paymentMethod = _data["paymentMethod"] !== undefined ? _data["paymentMethod"] : <any>null;
            this.orderCount = _data["orderCount"] !== undefined ? _data["orderCount"] : <any>null;
            this.totalAmount = _data["totalAmount"] !== undefined ? _data["totalAmount"] : <any>null;
            this.percentage = _data["percentage"] !== undefined ? _data["percentage"] : <any>null;
        }
    }

    static fromJS(data: any): PaymentMethodBreakdownDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodBreakdownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentMethod"] = this.paymentMethod !== undefined ? this.paymentMethod : <any>null;
        data["orderCount"] = this.orderCount !== undefined ? this.orderCount : <any>null;
        data["totalAmount"] = this.totalAmount !== undefined ? this.totalAmount : <any>null;
        data["percentage"] = this.percentage !== undefined ? this.percentage : <any>null;
        return data;
    }
}

export class TopCategoryDto {
    categoryId!: number;
    categoryName!: string;
    orderCount!: number;
    totalRevenue!: number;
    vehicleCount!: number;

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"] !== undefined ? _data["categoryId"] : <any>null;
            this.categoryName = _data["categoryName"] !== undefined ? _data["categoryName"] : <any>null;
            this.orderCount = _data["orderCount"] !== undefined ? _data["orderCount"] : <any>null;
            this.totalRevenue = _data["totalRevenue"] !== undefined ? _data["totalRevenue"] : <any>null;
            this.vehicleCount = _data["vehicleCount"] !== undefined ? _data["vehicleCount"] : <any>null;
        }
    }

    static fromJS(data: any): TopCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new TopCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : <any>null;
        data["categoryName"] = this.categoryName !== undefined ? this.categoryName : <any>null;
        data["orderCount"] = this.orderCount !== undefined ? this.orderCount : <any>null;
        data["totalRevenue"] = this.totalRevenue !== undefined ? this.totalRevenue : <any>null;
        data["vehicleCount"] = this.vehicleCount !== undefined ? this.vehicleCount : <any>null;
        return data;
    }
}

export class RecentOrderDto {
    orderId!: number;
    orderCode!: string;
    customerName!: string;
    subCategoryName!: string;
    orderTotal!: number;
    orderState!: string;
    createdDate!: Date;

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"] !== undefined ? _data["orderId"] : <any>null;
            this.orderCode = _data["orderCode"] !== undefined ? _data["orderCode"] : <any>null;
            this.customerName = _data["customerName"] !== undefined ? _data["customerName"] : <any>null;
            this.subCategoryName = _data["subCategoryName"] !== undefined ? _data["subCategoryName"] : <any>null;
            this.orderTotal = _data["orderTotal"] !== undefined ? _data["orderTotal"] : <any>null;
            this.orderState = _data["orderState"] !== undefined ? _data["orderState"] : <any>null;
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): RecentOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new RecentOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId !== undefined ? this.orderId : <any>null;
        data["orderCode"] = this.orderCode !== undefined ? this.orderCode : <any>null;
        data["customerName"] = this.customerName !== undefined ? this.customerName : <any>null;
        data["subCategoryName"] = this.subCategoryName !== undefined ? this.subCategoryName : <any>null;
        data["orderTotal"] = this.orderTotal !== undefined ? this.orderTotal : <any>null;
        data["orderState"] = this.orderState !== undefined ? this.orderState : <any>null;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>null;
        return data;
    }
}

export class OrdersByStateReportDto {
    orderState!: OrderState;
    orderStateName!: string;
    count!: number;

    init(_data?: any) {
        if (_data) {
            this.orderState = _data["orderState"] !== undefined ? _data["orderState"] : <any>null;
            this.orderStateName = _data["orderStateName"] !== undefined ? _data["orderStateName"] : <any>null;
            this.count = _data["count"] !== undefined ? _data["count"] : <any>null;
        }
    }

    static fromJS(data: any): OrdersByStateReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrdersByStateReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderState"] = this.orderState !== undefined ? this.orderState : <any>null;
        data["orderStateName"] = this.orderStateName !== undefined ? this.orderStateName : <any>null;
        data["count"] = this.count !== undefined ? this.count : <any>null;
        return data;
    }
}

export enum OrderState {
    Pending = 0,
    Confirmed = 1,
    OnWay = 2,
    CustomerReceived = 3,
    Completed = 4,
}

export class PagedResultOfOrderDto {
    items!: OrderDto[];
    totalCount!: number;
    pageNumber!: number;
    pageSize!: number;
    totalPages!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrderDto.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
            this.hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            this.hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): PagedResultOfOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export class OrderDto {
    orderId!: number;
    orderCode!: string;
    customerId!: number;
    customerName!: string;
    subCategoryId!: number;
    subCategoryName!: string;
    cityId!: number;
    cityName!: string;
    reservationDateFrom!: Date;
    reservationDateTo!: Date;
    vehiclesCount!: number;
    orderSubTotal!: number;
    orderTotal!: number;
    notes!: string | null;
    hotelName!: string;
    hotelAddress!: string;
    hotelPhone!: string | null;
    isUrgent!: boolean;
    paymentMethod!: PaymentMethod;
    orderState!: OrderState;
    createdDate!: Date;
    payPalApproveLink!: string | null;
    payPalOrderId!: string | null;

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"] !== undefined ? _data["orderId"] : <any>null;
            this.orderCode = _data["orderCode"] !== undefined ? _data["orderCode"] : <any>null;
            this.customerId = _data["customerId"] !== undefined ? _data["customerId"] : <any>null;
            this.customerName = _data["customerName"] !== undefined ? _data["customerName"] : <any>null;
            this.subCategoryId = _data["subCategoryId"] !== undefined ? _data["subCategoryId"] : <any>null;
            this.subCategoryName = _data["subCategoryName"] !== undefined ? _data["subCategoryName"] : <any>null;
            this.cityId = _data["cityId"] !== undefined ? _data["cityId"] : <any>null;
            this.cityName = _data["cityName"] !== undefined ? _data["cityName"] : <any>null;
            this.reservationDateFrom = _data["reservationDateFrom"] ? new Date(_data["reservationDateFrom"].toString()) : <any>null;
            this.reservationDateTo = _data["reservationDateTo"] ? new Date(_data["reservationDateTo"].toString()) : <any>null;
            this.vehiclesCount = _data["vehiclesCount"] !== undefined ? _data["vehiclesCount"] : <any>null;
            this.orderSubTotal = _data["orderSubTotal"] !== undefined ? _data["orderSubTotal"] : <any>null;
            this.orderTotal = _data["orderTotal"] !== undefined ? _data["orderTotal"] : <any>null;
            this.notes = _data["notes"] !== undefined ? _data["notes"] : <any>null;
            this.hotelName = _data["hotelName"] !== undefined ? _data["hotelName"] : <any>null;
            this.hotelAddress = _data["hotelAddress"] !== undefined ? _data["hotelAddress"] : <any>null;
            this.hotelPhone = _data["hotelPhone"] !== undefined ? _data["hotelPhone"] : <any>null;
            this.isUrgent = _data["isUrgent"] !== undefined ? _data["isUrgent"] : <any>null;
            this.paymentMethod = _data["paymentMethod"] !== undefined ? _data["paymentMethod"] : <any>null;
            this.orderState = _data["orderState"] !== undefined ? _data["orderState"] : <any>null;
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>null;
            this.payPalApproveLink = _data["payPalApproveLink"] !== undefined ? _data["payPalApproveLink"] : <any>null;
            this.payPalOrderId = _data["payPalOrderId"] !== undefined ? _data["payPalOrderId"] : <any>null;
        }
    }

    static fromJS(data: any): OrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId !== undefined ? this.orderId : <any>null;
        data["orderCode"] = this.orderCode !== undefined ? this.orderCode : <any>null;
        data["customerId"] = this.customerId !== undefined ? this.customerId : <any>null;
        data["customerName"] = this.customerName !== undefined ? this.customerName : <any>null;
        data["subCategoryId"] = this.subCategoryId !== undefined ? this.subCategoryId : <any>null;
        data["subCategoryName"] = this.subCategoryName !== undefined ? this.subCategoryName : <any>null;
        data["cityId"] = this.cityId !== undefined ? this.cityId : <any>null;
        data["cityName"] = this.cityName !== undefined ? this.cityName : <any>null;
        data["reservationDateFrom"] = this.reservationDateFrom ? this.reservationDateFrom.toISOString() : <any>null;
        data["reservationDateTo"] = this.reservationDateTo ? this.reservationDateTo.toISOString() : <any>null;
        data["vehiclesCount"] = this.vehiclesCount !== undefined ? this.vehiclesCount : <any>null;
        data["orderSubTotal"] = this.orderSubTotal !== undefined ? this.orderSubTotal : <any>null;
        data["orderTotal"] = this.orderTotal !== undefined ? this.orderTotal : <any>null;
        data["notes"] = this.notes !== undefined ? this.notes : <any>null;
        data["hotelName"] = this.hotelName !== undefined ? this.hotelName : <any>null;
        data["hotelAddress"] = this.hotelAddress !== undefined ? this.hotelAddress : <any>null;
        data["hotelPhone"] = this.hotelPhone !== undefined ? this.hotelPhone : <any>null;
        data["isUrgent"] = this.isUrgent !== undefined ? this.isUrgent : <any>null;
        data["paymentMethod"] = this.paymentMethod !== undefined ? this.paymentMethod : <any>null;
        data["orderState"] = this.orderState !== undefined ? this.orderState : <any>null;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>null;
        data["payPalApproveLink"] = this.payPalApproveLink !== undefined ? this.payPalApproveLink : <any>null;
        data["payPalOrderId"] = this.payPalOrderId !== undefined ? this.payPalOrderId : <any>null;
        return data;
    }
}

export enum PaymentMethod {
    Cash = 0,
    PayPal = 1,
}

export class OrderDetailDto {
    orderId!: number;
    orderCode!: string;
    customerId!: number;
    customerName!: string;
    customerMobileNumber!: string;
    subCategoryId!: number;
    subCategoryName!: string;
    subCategoryPrice!: number;
    cityId!: number;
    cityName!: string;
    reservationDateFrom!: Date;
    reservationDateTo!: Date;
    vehiclesCount!: number;
    orderSubTotal!: number;
    orderTotal!: number;
    notes!: string | null;
    passportImage!: string;
    hotelName!: string;
    hotelAddress!: string;
    hotelPhone!: string | null;
    isUrgent!: boolean;
    paymentMethod!: PaymentMethod;
    orderState!: OrderState;
    createdDate!: Date;
    orderVehicles!: OrderVehicleDto[];
    orderPayments!: OrderPaymentDto[];
    orderCancellationFee!: OrderCancellationFeeDto | null;
    refundablePaypalAmount!: RefundablePaypalAmountDto | null;
    orderTotals!: OrderTotalsDto | null;

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"] !== undefined ? _data["orderId"] : <any>null;
            this.orderCode = _data["orderCode"] !== undefined ? _data["orderCode"] : <any>null;
            this.customerId = _data["customerId"] !== undefined ? _data["customerId"] : <any>null;
            this.customerName = _data["customerName"] !== undefined ? _data["customerName"] : <any>null;
            this.customerMobileNumber = _data["customerMobileNumber"] !== undefined ? _data["customerMobileNumber"] : <any>null;
            this.subCategoryId = _data["subCategoryId"] !== undefined ? _data["subCategoryId"] : <any>null;
            this.subCategoryName = _data["subCategoryName"] !== undefined ? _data["subCategoryName"] : <any>null;
            this.subCategoryPrice = _data["subCategoryPrice"] !== undefined ? _data["subCategoryPrice"] : <any>null;
            this.cityId = _data["cityId"] !== undefined ? _data["cityId"] : <any>null;
            this.cityName = _data["cityName"] !== undefined ? _data["cityName"] : <any>null;
            this.reservationDateFrom = _data["reservationDateFrom"] ? new Date(_data["reservationDateFrom"].toString()) : <any>null;
            this.reservationDateTo = _data["reservationDateTo"] ? new Date(_data["reservationDateTo"].toString()) : <any>null;
            this.vehiclesCount = _data["vehiclesCount"] !== undefined ? _data["vehiclesCount"] : <any>null;
            this.orderSubTotal = _data["orderSubTotal"] !== undefined ? _data["orderSubTotal"] : <any>null;
            this.orderTotal = _data["orderTotal"] !== undefined ? _data["orderTotal"] : <any>null;
            this.notes = _data["notes"] !== undefined ? _data["notes"] : <any>null;
            this.passportImage = _data["passportImage"] !== undefined ? _data["passportImage"] : <any>null;
            this.hotelName = _data["hotelName"] !== undefined ? _data["hotelName"] : <any>null;
            this.hotelAddress = _data["hotelAddress"] !== undefined ? _data["hotelAddress"] : <any>null;
            this.hotelPhone = _data["hotelPhone"] !== undefined ? _data["hotelPhone"] : <any>null;
            this.isUrgent = _data["isUrgent"] !== undefined ? _data["isUrgent"] : <any>null;
            this.paymentMethod = _data["paymentMethod"] !== undefined ? _data["paymentMethod"] : <any>null;
            this.orderState = _data["orderState"] !== undefined ? _data["orderState"] : <any>null;
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>null;
            if (Array.isArray(_data["orderVehicles"])) {
                this.orderVehicles = [] as any;
                for (let item of _data["orderVehicles"])
                    this.orderVehicles!.push(OrderVehicleDto.fromJS(item));
            }
            else {
                this.orderVehicles = <any>null;
            }
            if (Array.isArray(_data["orderPayments"])) {
                this.orderPayments = [] as any;
                for (let item of _data["orderPayments"])
                    this.orderPayments!.push(OrderPaymentDto.fromJS(item));
            }
            else {
                this.orderPayments = <any>null;
            }
            this.orderCancellationFee = _data["orderCancellationFee"] ? OrderCancellationFeeDto.fromJS(_data["orderCancellationFee"]) : <any>null;
            this.refundablePaypalAmount = _data["refundablePaypalAmount"] ? RefundablePaypalAmountDto.fromJS(_data["refundablePaypalAmount"]) : <any>null;
            this.orderTotals = _data["orderTotals"] ? OrderTotalsDto.fromJS(_data["orderTotals"]) : <any>null;
        }
    }

    static fromJS(data: any): OrderDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId !== undefined ? this.orderId : <any>null;
        data["orderCode"] = this.orderCode !== undefined ? this.orderCode : <any>null;
        data["customerId"] = this.customerId !== undefined ? this.customerId : <any>null;
        data["customerName"] = this.customerName !== undefined ? this.customerName : <any>null;
        data["customerMobileNumber"] = this.customerMobileNumber !== undefined ? this.customerMobileNumber : <any>null;
        data["subCategoryId"] = this.subCategoryId !== undefined ? this.subCategoryId : <any>null;
        data["subCategoryName"] = this.subCategoryName !== undefined ? this.subCategoryName : <any>null;
        data["subCategoryPrice"] = this.subCategoryPrice !== undefined ? this.subCategoryPrice : <any>null;
        data["cityId"] = this.cityId !== undefined ? this.cityId : <any>null;
        data["cityName"] = this.cityName !== undefined ? this.cityName : <any>null;
        data["reservationDateFrom"] = this.reservationDateFrom ? this.reservationDateFrom.toISOString() : <any>null;
        data["reservationDateTo"] = this.reservationDateTo ? this.reservationDateTo.toISOString() : <any>null;
        data["vehiclesCount"] = this.vehiclesCount !== undefined ? this.vehiclesCount : <any>null;
        data["orderSubTotal"] = this.orderSubTotal !== undefined ? this.orderSubTotal : <any>null;
        data["orderTotal"] = this.orderTotal !== undefined ? this.orderTotal : <any>null;
        data["notes"] = this.notes !== undefined ? this.notes : <any>null;
        data["passportImage"] = this.passportImage !== undefined ? this.passportImage : <any>null;
        data["hotelName"] = this.hotelName !== undefined ? this.hotelName : <any>null;
        data["hotelAddress"] = this.hotelAddress !== undefined ? this.hotelAddress : <any>null;
        data["hotelPhone"] = this.hotelPhone !== undefined ? this.hotelPhone : <any>null;
        data["isUrgent"] = this.isUrgent !== undefined ? this.isUrgent : <any>null;
        data["paymentMethod"] = this.paymentMethod !== undefined ? this.paymentMethod : <any>null;
        data["orderState"] = this.orderState !== undefined ? this.orderState : <any>null;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>null;
        if (Array.isArray(this.orderVehicles)) {
            data["orderVehicles"] = [];
            for (let item of this.orderVehicles)
                data["orderVehicles"].push(item.toJSON());
        }
        if (Array.isArray(this.orderPayments)) {
            data["orderPayments"] = [];
            for (let item of this.orderPayments)
                data["orderPayments"].push(item.toJSON());
        }
        data["orderCancellationFee"] = this.orderCancellationFee ? this.orderCancellationFee.toJSON() : <any>null;
        data["refundablePaypalAmount"] = this.refundablePaypalAmount ? this.refundablePaypalAmount.toJSON() : <any>null;
        data["orderTotals"] = this.orderTotals ? this.orderTotals.toJSON() : <any>null;
        return data;
    }
}

export class OrderVehicleDto {
    vehicleId!: number;
    vehicleName!: string;
    vehicleCode!: string;
    status!: string;

    init(_data?: any) {
        if (_data) {
            this.vehicleId = _data["vehicleId"] !== undefined ? _data["vehicleId"] : <any>null;
            this.vehicleName = _data["vehicleName"] !== undefined ? _data["vehicleName"] : <any>null;
            this.vehicleCode = _data["vehicleCode"] !== undefined ? _data["vehicleCode"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
        }
    }

    static fromJS(data: any): OrderVehicleDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderVehicleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicleId"] = this.vehicleId !== undefined ? this.vehicleId : <any>null;
        data["vehicleName"] = this.vehicleName !== undefined ? this.vehicleName : <any>null;
        data["vehicleCode"] = this.vehicleCode !== undefined ? this.vehicleCode : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        return data;
    }
}

export class OrderPaymentDto {
    id!: number;
    orderId!: number;
    paymentMethod!: PaymentMethod;
    total!: number;
    state!: PaymentState;
    createdDate!: Date;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.orderId = _data["orderId"] !== undefined ? _data["orderId"] : <any>null;
            this.paymentMethod = _data["paymentMethod"] !== undefined ? _data["paymentMethod"] : <any>null;
            this.total = _data["total"] !== undefined ? _data["total"] : <any>null;
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): OrderPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["orderId"] = this.orderId !== undefined ? this.orderId : <any>null;
        data["paymentMethod"] = this.paymentMethod !== undefined ? this.paymentMethod : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>null;
        return data;
    }
}

export enum PaymentState {
    Pending = 0,
    Paid = 1,
    Failed = 2,
    Refunded = 3,
}

export class OrderCancellationFeeDto {
    id!: number;
    customerId!: number;
    orderId!: number;
    amount!: number;
    state!: CancellationFeeState;
    createdDate!: Date;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.customerId = _data["customerId"] !== undefined ? _data["customerId"] : <any>null;
            this.orderId = _data["orderId"] !== undefined ? _data["orderId"] : <any>null;
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): OrderCancellationFeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderCancellationFeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["customerId"] = this.customerId !== undefined ? this.customerId : <any>null;
        data["orderId"] = this.orderId !== undefined ? this.orderId : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>null;
        return data;
    }
}

export enum CancellationFeeState {
    NotYet = 0,
    Paid = 1,
}

export class RefundablePaypalAmountDto {
    id!: number;
    customerId!: number;
    orderId!: number;
    orderTotal!: number;
    cancellationFees!: number;
    refundableAmount!: number;
    state!: RefundState;
    createdDate!: Date;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.customerId = _data["customerId"] !== undefined ? _data["customerId"] : <any>null;
            this.orderId = _data["orderId"] !== undefined ? _data["orderId"] : <any>null;
            this.orderTotal = _data["orderTotal"] !== undefined ? _data["orderTotal"] : <any>null;
            this.cancellationFees = _data["cancellationFees"] !== undefined ? _data["cancellationFees"] : <any>null;
            this.refundableAmount = _data["refundableAmount"] !== undefined ? _data["refundableAmount"] : <any>null;
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): RefundablePaypalAmountDto {
        data = typeof data === 'object' ? data : {};
        let result = new RefundablePaypalAmountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["customerId"] = this.customerId !== undefined ? this.customerId : <any>null;
        data["orderId"] = this.orderId !== undefined ? this.orderId : <any>null;
        data["orderTotal"] = this.orderTotal !== undefined ? this.orderTotal : <any>null;
        data["cancellationFees"] = this.cancellationFees !== undefined ? this.cancellationFees : <any>null;
        data["refundableAmount"] = this.refundableAmount !== undefined ? this.refundableAmount : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>null;
        return data;
    }
}

export enum RefundState {
    Pending = 0,
    Success = 1,
    Failed = 2,
}

export class OrderTotalsDto {
    id!: number;
    orderId!: number;
    subTotal!: number;
    serviceFees!: number;
    deliveryFees!: number;
    urgentFees!: number;
    totalAfterAllFees!: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.orderId = _data["orderId"] !== undefined ? _data["orderId"] : <any>null;
            this.subTotal = _data["subTotal"] !== undefined ? _data["subTotal"] : <any>null;
            this.serviceFees = _data["serviceFees"] !== undefined ? _data["serviceFees"] : <any>null;
            this.deliveryFees = _data["deliveryFees"] !== undefined ? _data["deliveryFees"] : <any>null;
            this.urgentFees = _data["urgentFees"] !== undefined ? _data["urgentFees"] : <any>null;
            this.totalAfterAllFees = _data["totalAfterAllFees"] !== undefined ? _data["totalAfterAllFees"] : <any>null;
        }
    }

    static fromJS(data: any): OrderTotalsDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderTotalsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["orderId"] = this.orderId !== undefined ? this.orderId : <any>null;
        data["subTotal"] = this.subTotal !== undefined ? this.subTotal : <any>null;
        data["serviceFees"] = this.serviceFees !== undefined ? this.serviceFees : <any>null;
        data["deliveryFees"] = this.deliveryFees !== undefined ? this.deliveryFees : <any>null;
        data["urgentFees"] = this.urgentFees !== undefined ? this.urgentFees : <any>null;
        data["totalAfterAllFees"] = this.totalAfterAllFees !== undefined ? this.totalAfterAllFees : <any>null;
        return data;
    }
}

export class UpdateOrderStateCommand {
    orderId!: number;
    newState!: OrderState;
    vehicleIds!: number[] | null;

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"] !== undefined ? _data["orderId"] : <any>null;
            this.newState = _data["newState"] !== undefined ? _data["newState"] : <any>null;
            if (Array.isArray(_data["vehicleIds"])) {
                this.vehicleIds = [] as any;
                for (let item of _data["vehicleIds"])
                    this.vehicleIds!.push(item);
            }
            else {
                this.vehicleIds = <any>null;
            }
        }
    }

    static fromJS(data: any): UpdateOrderStateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrderStateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId !== undefined ? this.orderId : <any>null;
        data["newState"] = this.newState !== undefined ? this.newState : <any>null;
        if (Array.isArray(this.vehicleIds)) {
            data["vehicleIds"] = [];
            for (let item of this.vehicleIds)
                data["vehicleIds"].push(item);
        }
        return data;
    }
}

export class VehicleUtilizationReportDto {
    vehicleId!: number;
    vehicleName!: string;
    vehicleCode!: string;
    totalDaysBooked!: number;
    totalOrders!: number;
    utilizationPercentage!: number;

    init(_data?: any) {
        if (_data) {
            this.vehicleId = _data["vehicleId"] !== undefined ? _data["vehicleId"] : <any>null;
            this.vehicleName = _data["vehicleName"] !== undefined ? _data["vehicleName"] : <any>null;
            this.vehicleCode = _data["vehicleCode"] !== undefined ? _data["vehicleCode"] : <any>null;
            this.totalDaysBooked = _data["totalDaysBooked"] !== undefined ? _data["totalDaysBooked"] : <any>null;
            this.totalOrders = _data["totalOrders"] !== undefined ? _data["totalOrders"] : <any>null;
            this.utilizationPercentage = _data["utilizationPercentage"] !== undefined ? _data["utilizationPercentage"] : <any>null;
        }
    }

    static fromJS(data: any): VehicleUtilizationReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleUtilizationReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicleId"] = this.vehicleId !== undefined ? this.vehicleId : <any>null;
        data["vehicleName"] = this.vehicleName !== undefined ? this.vehicleName : <any>null;
        data["vehicleCode"] = this.vehicleCode !== undefined ? this.vehicleCode : <any>null;
        data["totalDaysBooked"] = this.totalDaysBooked !== undefined ? this.totalDaysBooked : <any>null;
        data["totalOrders"] = this.totalOrders !== undefined ? this.totalOrders : <any>null;
        data["utilizationPercentage"] = this.utilizationPercentage !== undefined ? this.utilizationPercentage : <any>null;
        return data;
    }
}

export class PagedResultOfUserDto {
    items!: UserDto[];
    totalCount!: number;
    pageNumber!: number;
    pageSize!: number;
    totalPages!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserDto.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
            this.hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            this.hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): PagedResultOfUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export class UserDto {
    id!: number;
    userName!: string;
    email!: string | null;
    phoneNumber!: string | null;
    emailConfirmed!: boolean;
    phoneNumberConfirmed!: boolean;
    lockoutEnabled!: boolean;
    lockoutEnd!: Date | null;
    accessFailedCount!: number;
    active!: boolean;
    roles!: string[];
    createdDate!: Date;
    createdBy!: string | null;
    lastModifiedDate!: Date;
    lastModifiedBy!: string | null;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
            this.emailConfirmed = _data["emailConfirmed"] !== undefined ? _data["emailConfirmed"] : <any>null;
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"] !== undefined ? _data["phoneNumberConfirmed"] : <any>null;
            this.lockoutEnabled = _data["lockoutEnabled"] !== undefined ? _data["lockoutEnabled"] : <any>null;
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>null;
            this.accessFailedCount = _data["accessFailedCount"] !== undefined ? _data["accessFailedCount"] : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            else {
                this.roles = <any>null;
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>null;
            this.createdBy = _data["createdBy"] !== undefined ? _data["createdBy"] : <any>null;
            this.lastModifiedDate = _data["lastModifiedDate"] ? new Date(_data["lastModifiedDate"].toString()) : <any>null;
            this.lastModifiedBy = _data["lastModifiedBy"] !== undefined ? _data["lastModifiedBy"] : <any>null;
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["emailConfirmed"] = this.emailConfirmed !== undefined ? this.emailConfirmed : <any>null;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed !== undefined ? this.phoneNumberConfirmed : <any>null;
        data["lockoutEnabled"] = this.lockoutEnabled !== undefined ? this.lockoutEnabled : <any>null;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>null;
        data["accessFailedCount"] = this.accessFailedCount !== undefined ? this.accessFailedCount : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>null;
        data["createdBy"] = this.createdBy !== undefined ? this.createdBy : <any>null;
        data["lastModifiedDate"] = this.lastModifiedDate ? this.lastModifiedDate.toISOString() : <any>null;
        data["lastModifiedBy"] = this.lastModifiedBy !== undefined ? this.lastModifiedBy : <any>null;
        return data;
    }
}

export class CreateUserCommand {
    userName!: string;
    email!: string | null;
    phoneNumber!: string | null;
    password!: string;
    roleId!: number;

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
            this.roleId = _data["roleId"] !== undefined ? _data["roleId"] : <any>null;
        }
    }

    static fromJS(data: any): CreateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["roleId"] = this.roleId !== undefined ? this.roleId : <any>null;
        return data;
    }
}

export class UpdateUserCommand {
    userId!: number;
    userName!: string;
    email!: string | null;
    phoneNumber!: string | null;
    password!: string | null;
    roleId!: number;

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
            this.roleId = _data["roleId"] !== undefined ? _data["roleId"] : <any>null;
        }
    }

    static fromJS(data: any): UpdateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["roleId"] = this.roleId !== undefined ? this.roleId : <any>null;
        return data;
    }
}

export class PagedResultOfCategoryDto {
    items!: CategoryDto[];
    totalCount!: number;
    pageNumber!: number;
    pageSize!: number;
    totalPages!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CategoryDto.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
            this.hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            this.hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): PagedResultOfCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export class CategoryDto {
    categoryId!: number;
    name!: string;
    description!: string;
    imageUrl!: string | null;
    isActive!: boolean;
    subCategoryCount!: number;
    cityId!: number;
    cityName!: string;

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"] !== undefined ? _data["categoryId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.imageUrl = _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
            this.subCategoryCount = _data["subCategoryCount"] !== undefined ? _data["subCategoryCount"] : <any>null;
            this.cityId = _data["cityId"] !== undefined ? _data["cityId"] : <any>null;
            this.cityName = _data["cityName"] !== undefined ? _data["cityName"] : <any>null;
        }
    }

    static fromJS(data: any): CategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
        data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
        data["subCategoryCount"] = this.subCategoryCount !== undefined ? this.subCategoryCount : <any>null;
        data["cityId"] = this.cityId !== undefined ? this.cityId : <any>null;
        data["cityName"] = this.cityName !== undefined ? this.cityName : <any>null;
        return data;
    }
}

export class CategoryLookupDto {
    categoryId!: number;
    name!: string;

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"] !== undefined ? _data["categoryId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): CategoryLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

export class CreateCategoryCommand {
    name!: string;
    description!: string;
    cityId!: number;
    imageUrl!: string | null;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.cityId = _data["cityId"] !== undefined ? _data["cityId"] : <any>null;
            this.imageUrl = _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
        }
    }

    static fromJS(data: any): CreateCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["cityId"] = this.cityId !== undefined ? this.cityId : <any>null;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
        return data;
    }
}

export class UpdateCategoryCommand {
    categoryId!: number;
    name!: string;
    description!: string;
    cityId!: number;
    imageUrl!: string | null;

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"] !== undefined ? _data["categoryId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.cityId = _data["cityId"] !== undefined ? _data["cityId"] : <any>null;
            this.imageUrl = _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
        }
    }

    static fromJS(data: any): UpdateCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["cityId"] = this.cityId !== undefined ? this.cityId : <any>null;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
        return data;
    }
}

export class PagedResultOfCityDto {
    items!: CityDto[];
    totalCount!: number;
    pageNumber!: number;
    pageSize!: number;
    totalPages!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CityDto.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
            this.hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            this.hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): PagedResultOfCityDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfCityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export class CityDto {
    cityId!: number;
    name!: string;
    description!: string | null;
    isActive!: boolean;
    customerCount!: number;
    createdDate!: Date;

    init(_data?: any) {
        if (_data) {
            this.cityId = _data["cityId"] !== undefined ? _data["cityId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
            this.customerCount = _data["customerCount"] !== undefined ? _data["customerCount"] : <any>null;
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): CityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cityId"] = this.cityId !== undefined ? this.cityId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
        data["customerCount"] = this.customerCount !== undefined ? this.customerCount : <any>null;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>null;
        return data;
    }
}

export class AddCityCommand {
    name!: string;
    description!: string | null;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any): AddCityCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddCityCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

export class UpdateCityCommand {
    cityId!: number;
    name!: string;
    description!: string | null;

    init(_data?: any) {
        if (_data) {
            this.cityId = _data["cityId"] !== undefined ? _data["cityId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any): UpdateCityCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCityCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cityId"] = this.cityId !== undefined ? this.cityId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

export class RegisterCustomerResponse {
    customerId!: number;
    invitationCode!: string;
    message!: string;

    init(_data?: any) {
        if (_data) {
            this.customerId = _data["customerId"] !== undefined ? _data["customerId"] : <any>null;
            this.invitationCode = _data["invitationCode"] !== undefined ? _data["invitationCode"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
        }
    }

    static fromJS(data: any): RegisterCustomerResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterCustomerResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId !== undefined ? this.customerId : <any>null;
        data["invitationCode"] = this.invitationCode !== undefined ? this.invitationCode : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        return data;
    }
}

export class RegisterCustomerCommand {
    mobileNumber!: string;
    fullName!: string;
    gender!: string;
    cityId!: number;
    fullAddress!: string | null;
    personalImage!: string | null;
    registerAs!: number;
    verificationBy!: number;
    email!: string | null;
    password!: string;

    init(_data?: any) {
        if (_data) {
            this.mobileNumber = _data["mobileNumber"] !== undefined ? _data["mobileNumber"] : <any>null;
            this.fullName = _data["fullName"] !== undefined ? _data["fullName"] : <any>null;
            this.gender = _data["gender"] !== undefined ? _data["gender"] : <any>null;
            this.cityId = _data["cityId"] !== undefined ? _data["cityId"] : <any>null;
            this.fullAddress = _data["fullAddress"] !== undefined ? _data["fullAddress"] : <any>null;
            this.personalImage = _data["personalImage"] !== undefined ? _data["personalImage"] : <any>null;
            this.registerAs = _data["registerAs"] !== undefined ? _data["registerAs"] : <any>null;
            this.verificationBy = _data["verificationBy"] !== undefined ? _data["verificationBy"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): RegisterCustomerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterCustomerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mobileNumber"] = this.mobileNumber !== undefined ? this.mobileNumber : <any>null;
        data["fullName"] = this.fullName !== undefined ? this.fullName : <any>null;
        data["gender"] = this.gender !== undefined ? this.gender : <any>null;
        data["cityId"] = this.cityId !== undefined ? this.cityId : <any>null;
        data["fullAddress"] = this.fullAddress !== undefined ? this.fullAddress : <any>null;
        data["personalImage"] = this.personalImage !== undefined ? this.personalImage : <any>null;
        data["registerAs"] = this.registerAs !== undefined ? this.registerAs : <any>null;
        data["verificationBy"] = this.verificationBy !== undefined ? this.verificationBy : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export class ActivateCustomerCommand {
    mobileNumber!: string;
    invitationCode!: string;

    init(_data?: any) {
        if (_data) {
            this.mobileNumber = _data["mobileNumber"] !== undefined ? _data["mobileNumber"] : <any>null;
            this.invitationCode = _data["invitationCode"] !== undefined ? _data["invitationCode"] : <any>null;
        }
    }

    static fromJS(data: any): ActivateCustomerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateCustomerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mobileNumber"] = this.mobileNumber !== undefined ? this.mobileNumber : <any>null;
        data["invitationCode"] = this.invitationCode !== undefined ? this.invitationCode : <any>null;
        return data;
    }
}

export class LoginResponse {
    token!: string;
    refreshToken!: string;
    userId!: number;
    userName!: string;
    roles!: string[];
    customerId!: number;

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"] !== undefined ? _data["token"] : <any>null;
            this.refreshToken = _data["refreshToken"] !== undefined ? _data["refreshToken"] : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            else {
                this.roles = <any>null;
            }
            this.customerId = _data["customerId"] !== undefined ? _data["customerId"] : <any>null;
        }
    }

    static fromJS(data: any): LoginResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token !== undefined ? this.token : <any>null;
        data["refreshToken"] = this.refreshToken !== undefined ? this.refreshToken : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        data["customerId"] = this.customerId !== undefined ? this.customerId : <any>null;
        return data;
    }
}

export class CustomerLoginCommand {
    mobileNumber!: string;
    password!: string;

    init(_data?: any) {
        if (_data) {
            this.mobileNumber = _data["mobileNumber"] !== undefined ? _data["mobileNumber"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): CustomerLoginCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerLoginCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mobileNumber"] = this.mobileNumber !== undefined ? this.mobileNumber : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export class RefreshTokenResponse {
    token!: string;
    refreshToken!: string;

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"] !== undefined ? _data["token"] : <any>null;
            this.refreshToken = _data["refreshToken"] !== undefined ? _data["refreshToken"] : <any>null;
        }
    }

    static fromJS(data: any): RefreshTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token !== undefined ? this.token : <any>null;
        data["refreshToken"] = this.refreshToken !== undefined ? this.refreshToken : <any>null;
        return data;
    }
}

export class RefreshTokenCommand {
    token!: string;
    refreshToken!: string;

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"] !== undefined ? _data["token"] : <any>null;
            this.refreshToken = _data["refreshToken"] !== undefined ? _data["refreshToken"] : <any>null;
        }
    }

    static fromJS(data: any): RefreshTokenCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token !== undefined ? this.token : <any>null;
        data["refreshToken"] = this.refreshToken !== undefined ? this.refreshToken : <any>null;
        return data;
    }
}

export class CityLookupDto {
    cityId!: number;
    name!: string;

    init(_data?: any) {
        if (_data) {
            this.cityId = _data["cityId"] !== undefined ? _data["cityId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): CityLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new CityLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cityId"] = this.cityId !== undefined ? this.cityId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

export class CityFeesDto {
    cityId!: number;
    serviceFees!: number | null;
    deliveryFees!: number | null;
    urgentFees!: number | null;
    cancellationFees!: number | null;

    init(_data?: any) {
        if (_data) {
            this.cityId = _data["cityId"] !== undefined ? _data["cityId"] : <any>null;
            this.serviceFees = _data["serviceFees"] !== undefined ? _data["serviceFees"] : <any>null;
            this.deliveryFees = _data["deliveryFees"] !== undefined ? _data["deliveryFees"] : <any>null;
            this.urgentFees = _data["urgentFees"] !== undefined ? _data["urgentFees"] : <any>null;
            this.cancellationFees = _data["cancellationFees"] !== undefined ? _data["cancellationFees"] : <any>null;
        }
    }

    static fromJS(data: any): CityFeesDto {
        data = typeof data === 'object' ? data : {};
        let result = new CityFeesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cityId"] = this.cityId !== undefined ? this.cityId : <any>null;
        data["serviceFees"] = this.serviceFees !== undefined ? this.serviceFees : <any>null;
        data["deliveryFees"] = this.deliveryFees !== undefined ? this.deliveryFees : <any>null;
        data["urgentFees"] = this.urgentFees !== undefined ? this.urgentFees : <any>null;
        data["cancellationFees"] = this.cancellationFees !== undefined ? this.cancellationFees : <any>null;
        return data;
    }
}

export class ReservedDateDto {
    date!: Date;

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): ReservedDateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReservedDateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        return data;
    }
}

export class CreateOrderCommand {
    subCategoryId!: number;
    cityId!: number;
    reservationDateFrom!: Date;
    reservationDateTo!: Date;
    vehiclesCount!: number;
    notes!: string | null;
    passportImage!: string;
    hotelName!: string;
    hotelAddress!: string;
    hotelPhone!: string | null;
    isUrgent!: boolean;
    paymentMethodId!: number;
    mobileTotal!: number;

    init(_data?: any) {
        if (_data) {
            this.subCategoryId = _data["subCategoryId"] !== undefined ? _data["subCategoryId"] : <any>null;
            this.cityId = _data["cityId"] !== undefined ? _data["cityId"] : <any>null;
            this.reservationDateFrom = _data["reservationDateFrom"] ? new Date(_data["reservationDateFrom"].toString()) : <any>null;
            this.reservationDateTo = _data["reservationDateTo"] ? new Date(_data["reservationDateTo"].toString()) : <any>null;
            this.vehiclesCount = _data["vehiclesCount"] !== undefined ? _data["vehiclesCount"] : <any>null;
            this.notes = _data["notes"] !== undefined ? _data["notes"] : <any>null;
            this.passportImage = _data["passportImage"] !== undefined ? _data["passportImage"] : <any>null;
            this.hotelName = _data["hotelName"] !== undefined ? _data["hotelName"] : <any>null;
            this.hotelAddress = _data["hotelAddress"] !== undefined ? _data["hotelAddress"] : <any>null;
            this.hotelPhone = _data["hotelPhone"] !== undefined ? _data["hotelPhone"] : <any>null;
            this.isUrgent = _data["isUrgent"] !== undefined ? _data["isUrgent"] : <any>null;
            this.paymentMethodId = _data["paymentMethodId"] !== undefined ? _data["paymentMethodId"] : <any>null;
            this.mobileTotal = _data["mobileTotal"] !== undefined ? _data["mobileTotal"] : <any>null;
        }
    }

    static fromJS(data: any): CreateOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subCategoryId"] = this.subCategoryId !== undefined ? this.subCategoryId : <any>null;
        data["cityId"] = this.cityId !== undefined ? this.cityId : <any>null;
        data["reservationDateFrom"] = this.reservationDateFrom ? this.reservationDateFrom.toISOString() : <any>null;
        data["reservationDateTo"] = this.reservationDateTo ? this.reservationDateTo.toISOString() : <any>null;
        data["vehiclesCount"] = this.vehiclesCount !== undefined ? this.vehiclesCount : <any>null;
        data["notes"] = this.notes !== undefined ? this.notes : <any>null;
        data["passportImage"] = this.passportImage !== undefined ? this.passportImage : <any>null;
        data["hotelName"] = this.hotelName !== undefined ? this.hotelName : <any>null;
        data["hotelAddress"] = this.hotelAddress !== undefined ? this.hotelAddress : <any>null;
        data["hotelPhone"] = this.hotelPhone !== undefined ? this.hotelPhone : <any>null;
        data["isUrgent"] = this.isUrgent !== undefined ? this.isUrgent : <any>null;
        data["paymentMethodId"] = this.paymentMethodId !== undefined ? this.paymentMethodId : <any>null;
        data["mobileTotal"] = this.mobileTotal !== undefined ? this.mobileTotal : <any>null;
        return data;
    }
}

export class CompletePayPalPaymentResponseDto {
    isSuccess!: boolean;
    transactionId!: string | null;
    message!: string;

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            this.transactionId = _data["transactionId"] !== undefined ? _data["transactionId"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
        }
    }

    static fromJS(data: any): CompletePayPalPaymentResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompletePayPalPaymentResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        data["transactionId"] = this.transactionId !== undefined ? this.transactionId : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        return data;
    }
}

export class CompletePayPalPaymentRequestDto {
    orderId!: number;
    payPalOrderId!: string;

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"] !== undefined ? _data["orderId"] : <any>null;
            this.payPalOrderId = _data["payPalOrderId"] !== undefined ? _data["payPalOrderId"] : <any>null;
        }
    }

    static fromJS(data: any): CompletePayPalPaymentRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompletePayPalPaymentRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId !== undefined ? this.orderId : <any>null;
        data["payPalOrderId"] = this.payPalOrderId !== undefined ? this.payPalOrderId : <any>null;
        return data;
    }
}

export class SubCategoryDto {
    subCategoryId!: number;
    name!: string;
    description!: string;
    imageUrl!: string | null;
    isActive!: boolean;
    isOffer!: boolean;
    price!: number;
    categoryId!: number;
    categoryName!: string;
    cityId!: number;
    cityName!: string;
    vehicleCount!: number;

    init(_data?: any) {
        if (_data) {
            this.subCategoryId = _data["subCategoryId"] !== undefined ? _data["subCategoryId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.imageUrl = _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
            this.isOffer = _data["isOffer"] !== undefined ? _data["isOffer"] : <any>null;
            this.price = _data["price"] !== undefined ? _data["price"] : <any>null;
            this.categoryId = _data["categoryId"] !== undefined ? _data["categoryId"] : <any>null;
            this.categoryName = _data["categoryName"] !== undefined ? _data["categoryName"] : <any>null;
            this.cityId = _data["cityId"] !== undefined ? _data["cityId"] : <any>null;
            this.cityName = _data["cityName"] !== undefined ? _data["cityName"] : <any>null;
            this.vehicleCount = _data["vehicleCount"] !== undefined ? _data["vehicleCount"] : <any>null;
        }
    }

    static fromJS(data: any): SubCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subCategoryId"] = this.subCategoryId !== undefined ? this.subCategoryId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
        data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
        data["isOffer"] = this.isOffer !== undefined ? this.isOffer : <any>null;
        data["price"] = this.price !== undefined ? this.price : <any>null;
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : <any>null;
        data["categoryName"] = this.categoryName !== undefined ? this.categoryName : <any>null;
        data["cityId"] = this.cityId !== undefined ? this.cityId : <any>null;
        data["cityName"] = this.cityName !== undefined ? this.cityName : <any>null;
        data["vehicleCount"] = this.vehicleCount !== undefined ? this.vehicleCount : <any>null;
        return data;
    }
}

export class RoleDto {
    roleId!: number;
    roleName!: string;
    createdDate!: Date;
    lastModifiedDate!: Date;

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"] !== undefined ? _data["roleId"] : <any>null;
            this.roleName = _data["roleName"] !== undefined ? _data["roleName"] : <any>null;
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>null;
            this.lastModifiedDate = _data["lastModifiedDate"] ? new Date(_data["lastModifiedDate"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId !== undefined ? this.roleId : <any>null;
        data["roleName"] = this.roleName !== undefined ? this.roleName : <any>null;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>null;
        data["lastModifiedDate"] = this.lastModifiedDate ? this.lastModifiedDate.toISOString() : <any>null;
        return data;
    }
}

export class CreateRoleCommand {
    roleName!: string;

    init(_data?: any) {
        if (_data) {
            this.roleName = _data["roleName"] !== undefined ? _data["roleName"] : <any>null;
        }
    }

    static fromJS(data: any): CreateRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleName"] = this.roleName !== undefined ? this.roleName : <any>null;
        return data;
    }
}

export class UpdateRoleCommand {
    roleId!: number;
    roleName!: string;

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"] !== undefined ? _data["roleId"] : <any>null;
            this.roleName = _data["roleName"] !== undefined ? _data["roleName"] : <any>null;
        }
    }

    static fromJS(data: any): UpdateRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId !== undefined ? this.roleId : <any>null;
        data["roleName"] = this.roleName !== undefined ? this.roleName : <any>null;
        return data;
    }
}

export class AssignRoleToUserCommand {
    userId!: number;
    roleId!: number;

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.roleId = _data["roleId"] !== undefined ? _data["roleId"] : <any>null;
        }
    }

    static fromJS(data: any): AssignRoleToUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AssignRoleToUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["roleId"] = this.roleId !== undefined ? this.roleId : <any>null;
        return data;
    }
}

export class RemoveRoleFromUserCommand {
    userId!: number;
    roleId!: number;

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.roleId = _data["roleId"] !== undefined ? _data["roleId"] : <any>null;
        }
    }

    static fromJS(data: any): RemoveRoleFromUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveRoleFromUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["roleId"] = this.roleId !== undefined ? this.roleId : <any>null;
        return data;
    }
}

export class PagedResultOfSubCategoryDto {
    items!: SubCategoryDto[];
    totalCount!: number;
    pageNumber!: number;
    pageSize!: number;
    totalPages!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SubCategoryDto.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
            this.hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            this.hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): PagedResultOfSubCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfSubCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export class SubCategoryLookupDto {
    subCategoryId!: number;
    name!: string;
    categoryId!: number;
    categoryName!: string;
    price!: number;

    init(_data?: any) {
        if (_data) {
            this.subCategoryId = _data["subCategoryId"] !== undefined ? _data["subCategoryId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.categoryId = _data["categoryId"] !== undefined ? _data["categoryId"] : <any>null;
            this.categoryName = _data["categoryName"] !== undefined ? _data["categoryName"] : <any>null;
            this.price = _data["price"] !== undefined ? _data["price"] : <any>null;
        }
    }

    static fromJS(data: any): SubCategoryLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubCategoryLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subCategoryId"] = this.subCategoryId !== undefined ? this.subCategoryId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : <any>null;
        data["categoryName"] = this.categoryName !== undefined ? this.categoryName : <any>null;
        data["price"] = this.price !== undefined ? this.price : <any>null;
        return data;
    }
}

export class CreateSubCategoryCommand {
    name!: string;
    description!: string;
    categoryId!: number;
    price!: number;
    isOffer!: boolean;
    imageUrl!: string | null;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.categoryId = _data["categoryId"] !== undefined ? _data["categoryId"] : <any>null;
            this.price = _data["price"] !== undefined ? _data["price"] : <any>null;
            this.isOffer = _data["isOffer"] !== undefined ? _data["isOffer"] : <any>null;
            this.imageUrl = _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
        }
    }

    static fromJS(data: any): CreateSubCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSubCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : <any>null;
        data["price"] = this.price !== undefined ? this.price : <any>null;
        data["isOffer"] = this.isOffer !== undefined ? this.isOffer : <any>null;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
        return data;
    }
}

export class UpdateSubCategoryCommand {
    subCategoryId!: number;
    name!: string;
    description!: string;
    categoryId!: number;
    price!: number;
    isOffer!: boolean;
    imageUrl!: string | null;

    init(_data?: any) {
        if (_data) {
            this.subCategoryId = _data["subCategoryId"] !== undefined ? _data["subCategoryId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.categoryId = _data["categoryId"] !== undefined ? _data["categoryId"] : <any>null;
            this.price = _data["price"] !== undefined ? _data["price"] : <any>null;
            this.isOffer = _data["isOffer"] !== undefined ? _data["isOffer"] : <any>null;
            this.imageUrl = _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
        }
    }

    static fromJS(data: any): UpdateSubCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSubCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subCategoryId"] = this.subCategoryId !== undefined ? this.subCategoryId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : <any>null;
        data["price"] = this.price !== undefined ? this.price : <any>null;
        data["isOffer"] = this.isOffer !== undefined ? this.isOffer : <any>null;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
        return data;
    }
}

export class PagedResultOfVehicleDto {
    items!: VehicleDto[];
    totalCount!: number;
    pageNumber!: number;
    pageSize!: number;
    totalPages!: number;
    hasPreviousPage!: boolean;
    hasNextPage!: boolean;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(VehicleDto.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
            this.hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            this.hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
        }
    }

    static fromJS(data: any): PagedResultOfVehicleDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfVehicleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        return data;
    }
}

export class VehicleDto {
    vehicleId!: number;
    name!: string;
    vehicleCode!: string;
    imageUrl!: string | null;
    status!: string;
    subCategoryId!: number;
    subCategoryName!: string;
    subCategoryPrice!: number;
    categoryId!: number;
    categoryName!: string;
    cityId!: number;
    cityName!: string;
    isNewThisMonth!: boolean;

    init(_data?: any) {
        if (_data) {
            this.vehicleId = _data["vehicleId"] !== undefined ? _data["vehicleId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.vehicleCode = _data["vehicleCode"] !== undefined ? _data["vehicleCode"] : <any>null;
            this.imageUrl = _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.subCategoryId = _data["subCategoryId"] !== undefined ? _data["subCategoryId"] : <any>null;
            this.subCategoryName = _data["subCategoryName"] !== undefined ? _data["subCategoryName"] : <any>null;
            this.subCategoryPrice = _data["subCategoryPrice"] !== undefined ? _data["subCategoryPrice"] : <any>null;
            this.categoryId = _data["categoryId"] !== undefined ? _data["categoryId"] : <any>null;
            this.categoryName = _data["categoryName"] !== undefined ? _data["categoryName"] : <any>null;
            this.cityId = _data["cityId"] !== undefined ? _data["cityId"] : <any>null;
            this.cityName = _data["cityName"] !== undefined ? _data["cityName"] : <any>null;
            this.isNewThisMonth = _data["isNewThisMonth"] !== undefined ? _data["isNewThisMonth"] : <any>null;
        }
    }

    static fromJS(data: any): VehicleDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicleId"] = this.vehicleId !== undefined ? this.vehicleId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["vehicleCode"] = this.vehicleCode !== undefined ? this.vehicleCode : <any>null;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["subCategoryId"] = this.subCategoryId !== undefined ? this.subCategoryId : <any>null;
        data["subCategoryName"] = this.subCategoryName !== undefined ? this.subCategoryName : <any>null;
        data["subCategoryPrice"] = this.subCategoryPrice !== undefined ? this.subCategoryPrice : <any>null;
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : <any>null;
        data["categoryName"] = this.categoryName !== undefined ? this.categoryName : <any>null;
        data["cityId"] = this.cityId !== undefined ? this.cityId : <any>null;
        data["cityName"] = this.cityName !== undefined ? this.cityName : <any>null;
        data["isNewThisMonth"] = this.isNewThisMonth !== undefined ? this.isNewThisMonth : <any>null;
        return data;
    }
}

export class CreateVehicleCommand {
    name!: string;
    vehicleCode!: string;
    subCategoryId!: number;
    status!: string;
    imageUrl!: string | null;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.vehicleCode = _data["vehicleCode"] !== undefined ? _data["vehicleCode"] : <any>null;
            this.subCategoryId = _data["subCategoryId"] !== undefined ? _data["subCategoryId"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.imageUrl = _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
        }
    }

    static fromJS(data: any): CreateVehicleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateVehicleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["vehicleCode"] = this.vehicleCode !== undefined ? this.vehicleCode : <any>null;
        data["subCategoryId"] = this.subCategoryId !== undefined ? this.subCategoryId : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
        return data;
    }
}

export class UpdateVehicleCommand {
    vehicleId!: number;
    name!: string;
    vehicleCode!: string;
    subCategoryId!: number;
    status!: string;
    imageUrl!: string | null;

    init(_data?: any) {
        if (_data) {
            this.vehicleId = _data["vehicleId"] !== undefined ? _data["vehicleId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.vehicleCode = _data["vehicleCode"] !== undefined ? _data["vehicleCode"] : <any>null;
            this.subCategoryId = _data["subCategoryId"] !== undefined ? _data["subCategoryId"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.imageUrl = _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
        }
    }

    static fromJS(data: any): UpdateVehicleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateVehicleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicleId"] = this.vehicleId !== undefined ? this.vehicleId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["vehicleCode"] = this.vehicleCode !== undefined ? this.vehicleCode : <any>null;
        data["subCategoryId"] = this.subCategoryId !== undefined ? this.subCategoryId : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
        return data;
    }
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}